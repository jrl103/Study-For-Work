# Hydration 과 dehydrate 과정

# Hydrate

- Next.js 의 주요 동작 방식
- 페이지가 브라우저에 로드되고 JS 코드가 실행되면서 페이지가 인터렉티브하게 동작하는 상태가 되는 과정
- Server Side 단에서 렌더링된 `정적 페이지와 번들링된 JS 파일 을 클라이언트에게 보낸 뒤`, `클라이언트단에서 HTML 코드와 React 인 JS 코드를 서로 매칭시키는 과정`
  - Next.js Server 에서는 `Pre-Rendering 된 웹 페이지`를 클라이언트에게 보내고 나서, 바로 리액트가 `번들링 된 JS 코드`들을 클라이언트에게 전송함


### 네트워크 탭을 보면
1. 맨 처음 응답받는 요소가 document Type 의 파일이고,
2. 이후에 React 코드들이 렌더링 된 JS 파일들이 Chunk 단위로 다운로드되는 것을 확인할 수 있음.
3. 그리고 이 JS 코드들이 이전에 보내진 HTML DOM 요소 위에서 한번 더 렌더링을 하면서, 각자 자기 자리를 찾아가며 매칭이 된다. 


--> 이 과정이 Hydrate 
: 마치 `자바스크립트 코드들이 DOM 요소 위에 물을 채우듯 필요로 하던 요소들을 채운다` 하여 `Hydrate(수화)`라는 용어를 씀
: 새롭게 페이지를 로딩할 때마다 약간 뒤늦게 스타일이 적용되는 듯한 이 과정이, `HTML DOM 요소에 뒤늦게 자바스크립트가 동작하고 Hydration 돼서 나타나는 현상`
: 어쩌면 두번 렌더링 하는 것은 비효율적으로 보일 수 있다. 그러나 서버 단에서 빠르게 `Pre-Rendering` 하고 `유저에게 빠른 웹 페이지로 응답할 수 있다`는 것에 더욱 큰 이점을 가져갈 수 있다. 심지어 이 Pre-Rendering 한 Document 는 모든 자바스크립트 요소들이 빠진 `굉장히 가벼운 상태`이므로 클라이언트에게 빠른 로딩이 가능하다.


# Dehydrate

- 수분을 없앤다 = 서버가 완성된 HTML 을 내려준다
- 동적인것을 정적으로 만드는 행위
- 그리고 나서 JS가 실행되면서 리액트가 `정적인 HTML 과 store 를 동적인 리액트 컴포넌트 트리와 store 로 변환하는 과정`이 일어나는데, 이걸 `(Re)hydrate` 라고 함
  - 문제는 이렇게 rehydrate 가 일어나면서 쓸데없이 화면이 한번더 그려지는 현상이 발생한다는 것
  - 왜냐면 리액트는 서버에서 완성된 HTML 이 내려와서 이미 화면에 제대로 렌더링이 됬는지 안됬는지 모르고 자신이 할일을 그냥 했을 뿐
  - 그래서 `SSR` 을 하는 경우에는 ReactDom 의 render 메소드가 아니라 `hydrate 메소드를 사용`해야 한다







































